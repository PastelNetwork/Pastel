// Copyright (c) 2010 Satoshi Nakamoto
// Copyright (c) 2009-2014 The Bitcoin Core developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

/*
 Genesis block for MainNet found
  nonce: 00000000000000000000000000000000000000000000000000000000000005ed
  solution: 005325345b09ae8f4b50503fd393b82870c0be383e15bcd9b4c989d8ab8b49530dfd75c5c4d0a4f10e5705514c93c622f2cd5b14333a6032cee54438dea2e8171a93bfb6ab2653d7e463004a34efe8c277b6cbb6074e47f0f8cbee75df592390fff4d10e40e13627b117ad3e7e6bb27495bfb5b3b2f16bee72a37adb65771e9c91f2fb98ecfffb1fa64da555fc22ab835aab7d46a94b7a4177b419fe27b5a7054ba605ad17d76f5e00df38279b6b2c8bf6b3798f1b5ad24749073ffd8d27f2de5c456bf505f257bb4423ebd44336a87a46da27c655c31d8aeff756e282c8fb3fa77d44b0d5c55e49bb757c166f0975b8423672be7d43ea563a9eb44f0155d4bf6e45ca28f271038d1841383d4a99f0d23204258257825865430248c1efa4e8ea9c812b469bc7216936c2a11e74d59b3f899e3259eeb718c19ce8d7360d2c757f13a96f8e8773a0b0b7e99ec6d21a052d037d2e421bcf547538da51bdcdf0978a1e5516c1bf0be6de8c380a295b34b2a27619ace92e2f1cf9ba41074de1374d09e37ca96ed260174d98ae2922b9e7ef0ee9b7cea0f0467be38962b0c5a356c5cce8f74c73075bfa8ec9158ebce51d238dc0bd296d1dfe7b561f1472810b5d868fad6bc55be662e0cedb221a9aec35108b3533ddd31b0d0238213fb4178a5cbb47fafb1e1534b2c037569bcae668a205c5fc9bcf1d8b9d9789037d4ef470aedfd198a3451145c63339f80577da8123b407f39ccbbd90e51a65adc7d9c189d2adffb0b925a8b7017e92657dd85f261c78c1d901cf177bed6c4a0065905a28b33feb20f7d125483c2abc193ad00403882acb42ada9e98addc19be5db2a7dcf0b76a5e20d16133f91094ba05ce031cb30d47f491c9f3ea321195cebdfebd8fa6799d104a317f0a6ce1905be742c39ffa2efb4d7fce5cfc616050aec0b4ddfb9172c3301559eb60d40ab0f6a2621d58f5631f4cacc995a7e09b19b7dc7c2fad8b5f3245d9e666a2a65debe55b11a28aa007c5d81d372f3338503f91f7b363bdf6aac6e7bcd68531cbafd8d5138050b6d30a27a3317a84505338d42ed01f426fee680f7162ac705bdf17d30195b9302e9b3ea7ad7598107fb997ad4ab13d97bc965206ad9e2866351e998a72532cf6e676743593d8ce021e14f5f1b56d0990fea65778abfb17e8a2e1ab12d0214d68496dd872dd7bbb4a87cf8dd827a5ef6bf2b28bfb5afde1763faca3d77919864d0d1ec92b00fa702a0ce65760955b4c347e22bcc9843d0ac295f13770473ecc8a641aebe16e2327ec8a5634303b65e487111b7672c9553ed333809e459d9abb2a96122afd83c5a9fa442b3b25d739ce4d5fa8fc34e5fb5d47ea7c4124fd5967a21667bacbb542a7efc1e69ecde32b7be2061edd42b0a3928669154675cd9710127879db14a03c1e4ded2cebba3d79853bb78dfc572062db3e9641a2274dc938c68edfff7eb06cb67a8c6eef13efff108467f0c47ca7ff58fa27462637675295e650e977d13290bc480c795593fef21829160f524dc1bc92c8a06c607427a8b3aff435881a5af7c8179fe339cb4656f7fadd2c95c96099e5249268d50fd7294719cfe9509c2fa53d606546bd00784d619cc5d2a1dea9f9559221eef64a4d002b7f19e6694bde69b89d2cc54d2b80487502ed209f70bec3115f2a069c73e5f297cd63b0df2fd4f8a9ee10d5212d1adb1f550453077cde68c0aa22daf0449967fa98010dc401bdb5c7a63f0e1ad19e89a1b28d4bd1f2bfef5875fdc6321ed4df5865806c8d37bed3086effde8f133e78cebb44d6c83c9514f928ec84a238593242119642cf23ec6e51d9bb627089b922e1c2ba657c0dce3f4bdfc932d868438cdfd257c8a8d7d4ecb3f65f785775e4b20664dd43499c4
  merkle root hash: d85566c213783a3b4e75d5561775f25e016c32d365dcad8f3cb10b7d48736df9
  header hash: 000279bc7e3c2826212c57582228d11b12561d746bb7b1114f4c6bd3f596a88a

 Genesis block for TestNet found
  nonce: 000000000000000000000000000000000000000000000000000000000000002a
  solution: 0065d44864ed91b19240140d0eff9bbe91097edc801c8b0773010c3183b71162c9a771c3beec999efd7416415c07854841b64fe41631b15ed296e16add0b06638fabea2bba30c1fad956622de3bbdabdb7d986380463234cc044214cb9a3f9043c721a62c058779c03105a02f50bf767f5c0156126394438b14e549cb7bc0f2885691f9e05b6f6b6c65696b7198a17f63f1837296d9236b0d872d7767b764f18c513d739891aafa315368620f88a62caae8f5167b00bcc72ab0095d58735b97b4030fb0503f5ccf3a9c3b5b851a9b4afb9bc1c77171685cb6b6b6bf254c458c48542a193193d5725fd0f0d7657ee91195459474bcd4df2f95fdb010915433db8f5dfbeeb4d4405b041c7408a10c658fb6819e2b1c98eec7233802741ef544dd9891664d5c6181bc8d14e75100b3512f0185e595024632bd1fa1846246993c5c2dd2f074a2752dcc2fafca18b44deedc800f7309a74d5208f3482c51fa37764b6f6eafa3a260b91ffb0b35cae652531818a07e7b464eef56b9a8905c8657980b60003b0338369709c801d3948f0e33a232d3fff13ec5c01b09335c2ef66a0a1838d73c9ed028a5b76ad00a6a4b853338d40a2c40a4a41f59bd053744b44b96a8d11b6df054363c99d9b6c0e5e28b811547f5af48471a522185477b3f2145e3a6b9cca432f75473dfecda3247e5b749d11ed25f269f8d534ff03cbac13141a0937f9f3508618553d2e093cb8d04206454bc085a4fa7fe836b1a9dde85a488319351bd826c4ae7981288e3189a265bc86475029f1bf9912a729ff977a27543e859e95c4cab4b213eea2ca5d08b211d1c1d267932ed528f321a169797312740f9f98a52afb1d1d94d526cf9d0f83a62044fa2ed9c819dd3e1359e6671c8605246a8fc578e3ce8001fb21712a961a6e350d560724f0cc58b628424ddc13608bff76b20089abef256270a7a247f1aa9a14a91cce728f2bf617d70913b590ab86e5d422e5283ef16ce5d3cf0cec17828a6cb1082082e898545d08d18f99b61a1ad8ca2bf47a37d4a2c72decbf24126641a0a25930de9756067603ee6d67bb63478d645cb3e378119075af2e672553bc0142fb4ec5e465e2da6621d51e196957ebcd119d4a635c0cadcf5083c3598ce4966d9706b283be26d04e660da9807deece57e80ad3d69e023cd5716701368b83625f95d716b1916cf64a45964d8ab5492c2662d64e240e1ebe73fcb2edad995e4f80f4dde577090e9d400a93a8a9af801957f07043ef91a9fd41405b43bc3e01a23e2f70fbc6229969da56f3ad5cb7e6040b767187ca62768c6e338e01a78f8a295b3ed5bf1bbed68454d7f747f5f0720cf2c560852cd6ab5d840dd8fa6d00095de27cbc5166cecc9740c436fdfc641378767180e87c5df721829b32ccad7cb58a73413a069bf44c6a0e0efb7f7b03f86c42e7954695f0ecf106c12f9dfe0cc25eea1734fb48c633d18fbd9d118206aebdb3f8a08f77ee6f7425bae3bd49942cf6cc2b0ed47a7f65a5256fc76ed2f2436c4eee2d335b4f3706ec7359a25512672dc4f07e7d7a24d91bdb6e82e011e6c1ca238a7ceb35af12a39cf1a924c1653d33a8106869db94523f450532e42fc034608d6162d127751dc3c14bba5dd20354df45d942c91a358ebf1c382207e2bf7094908f19aea665bede6323762e35bffa4f4fe282850ea490f36ef6d5f01d657b35b086f2016f27530efb80d37948a6d7c68dd0f2167e25f234837937140c08b9a19a3d7da9539227564fc1fda4b07afb0f40d0d66306eae721a7a2d413c70f9947406a7a47111612092a736b61a13b632a12d78c7a0b7056531e172802e8970d652de13085015a7601c58e4e370c171e819f74dd5f4b91310c53666cc6e311119e7bc6d6
  merkle root hash: 4960679a2604973b01cefbe6b59ea8235ae0c391223c5de9004de80ccc2cae88
  header hash: 07868deac6fb30e83f15d077a4ef3a5957d36f84793643ba9c8df475aa397e20

Genesis block for RegTest found
  nonce: 0000000000000000000000000000000000000000000000000000000000000009
  solution: 06feb49c057759b8dd1a9810ea32c191fda910e7f27b68f7c387e737ecdeb6e39b554d5f
  merkle root hash: bb4607614fef0af08e15357f533f0818d73a77c2589f67a56f30a08002b80cf1
  header hash: 0e584b4ae690899a4597b995b9434b81e2695606a74f4a5b83e1184f855253b9

 */

#include "key_io.h"
#include "main.h"
#include "crypto/equihash.h"

#include "util.h"
#include "utilstrencodings.h"

#include <assert.h>
#include <vector>

#include <boost/assign/list_of.hpp>

#include "chainparamsseeds.h"

using namespace std;

#define OVERWINTER_STARTING_BLOCK 10
#define SAPLING_STARTING_BLOCK 20

static CBlock CreateGenesisBlock(const char* pszTimestamp, 
                                 const std::vector<unsigned char> &genesisPubKey, 
                                 uint32_t nTime, 
                                 uint256 nNonce, 
                                 const std::vector<unsigned char> &nSolution, 
                                 uint32_t nBits, 
                                 int32_t nVersion = 4, 
                                 const CAmount& genesisReward = 0)
{
    CMutableTransaction txNew;
    txNew.nVersion = 1;
    txNew.vin.resize(1);
    txNew.vout.resize(1);
    txNew.vin[0].scriptSig = CScript() << (int)nBits << CScriptNum(4) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));
    txNew.vout[0].nValue = genesisReward;
    txNew.vout[0].scriptPubKey = CScript() << genesisPubKey << OP_CHECKSIG;

    CBlock genesis;
    genesis.nTime    = nTime;
    genesis.nBits    = nBits;
    genesis.nNonce   = nNonce;
    genesis.nSolution = nSolution;
    genesis.nVersion = nVersion;
    genesis.vtx.push_back(txNew);
    genesis.hashPrevBlock.SetNull();
    genesis.hashMerkleRoot = genesis.BuildMerkleTree();
    return genesis;
}

//#define MINE_GENESIS
#ifdef MINE_GENESIS
#define MINE_GENESIS_MAIN
#define MINE_GENESIS_TEST
#define MINE_GENESIS_REGT

namespace MineGenesis {
#include "pow/tromp/equi_miner.h"
static void __mineGenBlock(std::string network, bool tromp, unsigned int n, unsigned int k, CBlock *pblock)
{
    printf("Will be mining Genesis block for %s using %s solver\n", network.c_str(), tromp? "tromp": "default");

    pblock->nNonce.SetNull();
    pblock->nSolution.clear();

    arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);

    int counter = 0;
    bool bContinue = true;
    while (bContinue) {
        printf("\titteration %d\r", ++counter);
        fflush(stdout);

        // Hash state
        crypto_generichash_blake2b_state state;
        EhInitialiseState(n, k, state);

        // I = the block header minus nonce and solution.
        CEquihashInput I{*pblock};
        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
        ss << I;

        // H(I||...
        crypto_generichash_blake2b_update(&state, (unsigned char*)&ss[0], ss.size());

        // H(I||V||...
        crypto_generichash_blake2b_state curr_state;
        curr_state = state;
        crypto_generichash_blake2b_update(&curr_state,
                                            pblock->nNonce.begin(),
                                            pblock->nNonce.size());

        // (x_1, x_2, ...) = A(I, V, n, k)
        std::function<bool(std::vector<unsigned char>)> validBlock =
            [&network, &pblock, &hashTarget]
            (std::vector<unsigned char> soln) {
            
            // Write the solution to the hash and compute the result.
            pblock->nSolution = soln;

            if (UintToArith256(pblock->GetHash()) > hashTarget) {
                return false;
            }
            printf("Genesis block for %s found  \n  merkle root hash: %s\n  header hash: %s\n  nonce: %s\n  solution: %s\n",
                                                        network.c_str(),
                                                        pblock->hashMerkleRoot.GetHex().c_str(),
                                                        pblock->GetHash().GetHex().c_str(), 
                                                        pblock->nNonce.GetHex().c_str(),
                                                        HexStr(pblock->nSolution).c_str());

            return true;
        };

        if (tromp) {
            equi eq(1);
            eq.setstate(&curr_state);

            // Intialization done, start algo driver.
            eq.digit0(0);
            eq.xfull = eq.bfull = eq.hfull = 0;
            eq.showbsizes(0);
            for (u32 r = 1; r < WK; r++) {
                (r&1) ? eq.digitodd(r, 0) : eq.digiteven(r, 0);
                eq.xfull = eq.bfull = eq.hfull = 0;
                eq.showbsizes(r);
            }
            eq.digitK(0);

            // Convert solution indices to byte array (decompress) and pass it to validBlock method.
            for (size_t s = 0; s < eq.nsols; s++) {
                LogPrint("pow", "Checking solution %d\n", s+1);
                std::vector<eh_index> index_vector(PROOFSIZE);
                for (size_t i = 0; i < PROOFSIZE; i++) {
                    index_vector[i] = eq.sols[s][i];
                }
                std::vector<unsigned char> sol_char = GetMinimalFromIndices(index_vector, DIGITBITS);

                if (validBlock(sol_char)) {
                    // If we find a POW solution, do not try other solutions
                    // because they become invalid as we created a new block in blockchain.
                    bContinue = false;
                    break;
                }
            }
        } else if (EhOptimisedSolveUncancellable(n, k, curr_state, validBlock)) {
            break;
        }

        pblock->nNonce = ArithToUint256(UintToArith256(pblock->nNonce) + 1);
    }
}
}
#endif

/**
 * Build the genesis block. Note that the output of its generation
 * transaction cannot be spent since it did not originally exist in the
 * database (and is in any case of zero value).
 *
 * >>> from pyblake2 import blake2s
 * 
 * >>> 'Pascal' + blake2s(b'Forbes March 5, 2020 Bitcoin Faces Strong Resistance After Recent Rally BTC#620384 0000000000000000000d581747396c69ab4dfabe82184a8fc3bce9d7cdf92c6e ZEC#751112 000000000108d0a5d3fab52ff2908c56a2858a3babea15f78619f074f4fa3488 DJIA Mar 05, 2020 at 6:20 p.m. EST 26,121.28').hexdigest()
 * => Pascald8ddbf6b69fe45b8bc330b61678ef2aa27dd599e5c49361c1b879ccff2d098a9
 *
 * nTime - epoc time
 * 03/01/2020 00:00:00 GMT = 1583020800
 *
 */

static const std::vector<unsigned char> PastelGenesisPubKey = ParseHex("04b985ccafe6d17ac5d84cb8c06a69cefad733ee96b4b93bcf5ef0897778c227ee7e74e7680cc219236e4c6a609dbcdeb5bf65cea9c2576c2a0fbef590657c8e7a");
static const char* PastelGenesisTimestamp = "Pascald8ddbf6b69fe45b8bc330b61678ef2aa27dd599e5c49361c1b879ccff2d098a9";
static const uint32_t EpocTime = 1583020800;

static CBlock CreateMainnetGenesisBlock()
{
    uint32_t nTime = EpocTime;
    uint32_t nBits = 0x1f07ffff;

#ifdef MINE_GENESIS_MAIN
    uint256 nNonce = uint256S("0");
    std::vector<unsigned char> nSolution = ParseHex("0");
#else
    uint256 nNonce = uint256S("00000000000000000000000000000000000000000000000000000000000005ed");
    std::vector<unsigned char> nSolution = ParseHex("005325345b09ae8f4b50503fd393b82870c0be383e15bcd9b4c989d8ab8b49530dfd75c5c4d0a4f10e5705514c93c622f2cd5b14333a6032cee54438dea2e8171a93bfb6ab2653d7e463004a34efe8c277b6cbb6074e47f0f8cbee75df592390fff4d10e40e13627b117ad3e7e6bb27495bfb5b3b2f16bee72a37adb65771e9c91f2fb98ecfffb1fa64da555fc22ab835aab7d46a94b7a4177b419fe27b5a7054ba605ad17d76f5e00df38279b6b2c8bf6b3798f1b5ad24749073ffd8d27f2de5c456bf505f257bb4423ebd44336a87a46da27c655c31d8aeff756e282c8fb3fa77d44b0d5c55e49bb757c166f0975b8423672be7d43ea563a9eb44f0155d4bf6e45ca28f271038d1841383d4a99f0d23204258257825865430248c1efa4e8ea9c812b469bc7216936c2a11e74d59b3f899e3259eeb718c19ce8d7360d2c757f13a96f8e8773a0b0b7e99ec6d21a052d037d2e421bcf547538da51bdcdf0978a1e5516c1bf0be6de8c380a295b34b2a27619ace92e2f1cf9ba41074de1374d09e37ca96ed260174d98ae2922b9e7ef0ee9b7cea0f0467be38962b0c5a356c5cce8f74c73075bfa8ec9158ebce51d238dc0bd296d1dfe7b561f1472810b5d868fad6bc55be662e0cedb221a9aec35108b3533ddd31b0d0238213fb4178a5cbb47fafb1e1534b2c037569bcae668a205c5fc9bcf1d8b9d9789037d4ef470aedfd198a3451145c63339f80577da8123b407f39ccbbd90e51a65adc7d9c189d2adffb0b925a8b7017e92657dd85f261c78c1d901cf177bed6c4a0065905a28b33feb20f7d125483c2abc193ad00403882acb42ada9e98addc19be5db2a7dcf0b76a5e20d16133f91094ba05ce031cb30d47f491c9f3ea321195cebdfebd8fa6799d104a317f0a6ce1905be742c39ffa2efb4d7fce5cfc616050aec0b4ddfb9172c3301559eb60d40ab0f6a2621d58f5631f4cacc995a7e09b19b7dc7c2fad8b5f3245d9e666a2a65debe55b11a28aa007c5d81d372f3338503f91f7b363bdf6aac6e7bcd68531cbafd8d5138050b6d30a27a3317a84505338d42ed01f426fee680f7162ac705bdf17d30195b9302e9b3ea7ad7598107fb997ad4ab13d97bc965206ad9e2866351e998a72532cf6e676743593d8ce021e14f5f1b56d0990fea65778abfb17e8a2e1ab12d0214d68496dd872dd7bbb4a87cf8dd827a5ef6bf2b28bfb5afde1763faca3d77919864d0d1ec92b00fa702a0ce65760955b4c347e22bcc9843d0ac295f13770473ecc8a641aebe16e2327ec8a5634303b65e487111b7672c9553ed333809e459d9abb2a96122afd83c5a9fa442b3b25d739ce4d5fa8fc34e5fb5d47ea7c4124fd5967a21667bacbb542a7efc1e69ecde32b7be2061edd42b0a3928669154675cd9710127879db14a03c1e4ded2cebba3d79853bb78dfc572062db3e9641a2274dc938c68edfff7eb06cb67a8c6eef13efff108467f0c47ca7ff58fa27462637675295e650e977d13290bc480c795593fef21829160f524dc1bc92c8a06c607427a8b3aff435881a5af7c8179fe339cb4656f7fadd2c95c96099e5249268d50fd7294719cfe9509c2fa53d606546bd00784d619cc5d2a1dea9f9559221eef64a4d002b7f19e6694bde69b89d2cc54d2b80487502ed209f70bec3115f2a069c73e5f297cd63b0df2fd4f8a9ee10d5212d1adb1f550453077cde68c0aa22daf0449967fa98010dc401bdb5c7a63f0e1ad19e89a1b28d4bd1f2bfef5875fdc6321ed4df5865806c8d37bed3086effde8f133e78cebb44d6c83c9514f928ec84a238593242119642cf23ec6e51d9bb627089b922e1c2ba657c0dce3f4bdfc932d868438cdfd257c8a8d7d4ecb3f65f785775e4b20664dd43499c4");
#endif

    CBlock block = CreateGenesisBlock(PastelGenesisTimestamp, PastelGenesisPubKey, EpocTime, nNonce, nSolution, nBits);

#ifdef MINE_GENESIS_MAIN
    MineGenesis::__mineGenBlock("MainNet", true, 200, 9, &block);
#endif

    return block;
}
static const uint256 MainnetHashMerkleRoot = uint256S("d85566c213783a3b4e75d5561775f25e016c32d365dcad8f3cb10b7d48736df9");
static const uint256 MainnetHashGenesisBlock = uint256S("000279bc7e3c2826212c57582228d11b12561d746bb7b1114f4c6bd3f596a88a");

static CBlock CreateTestnetGenesisBlock()
{
    uint32_t nTime = EpocTime;
    uint32_t nBits = 0x2007ffff;

#ifdef MINE_GENESIS_TEST
    uint256 nNonce = uint256S("0");
    std::vector<unsigned char> nSolution = ParseHex("0");
#else
    uint256 nNonce = uint256S("000000000000000000000000000000000000000000000000000000000000002a");
    std::vector<unsigned char> nSolution = ParseHex("0065d44864ed91b19240140d0eff9bbe91097edc801c8b0773010c3183b71162c9a771c3beec999efd7416415c07854841b64fe41631b15ed296e16add0b06638fabea2bba30c1fad956622de3bbdabdb7d986380463234cc044214cb9a3f9043c721a62c058779c03105a02f50bf767f5c0156126394438b14e549cb7bc0f2885691f9e05b6f6b6c65696b7198a17f63f1837296d9236b0d872d7767b764f18c513d739891aafa315368620f88a62caae8f5167b00bcc72ab0095d58735b97b4030fb0503f5ccf3a9c3b5b851a9b4afb9bc1c77171685cb6b6b6bf254c458c48542a193193d5725fd0f0d7657ee91195459474bcd4df2f95fdb010915433db8f5dfbeeb4d4405b041c7408a10c658fb6819e2b1c98eec7233802741ef544dd9891664d5c6181bc8d14e75100b3512f0185e595024632bd1fa1846246993c5c2dd2f074a2752dcc2fafca18b44deedc800f7309a74d5208f3482c51fa37764b6f6eafa3a260b91ffb0b35cae652531818a07e7b464eef56b9a8905c8657980b60003b0338369709c801d3948f0e33a232d3fff13ec5c01b09335c2ef66a0a1838d73c9ed028a5b76ad00a6a4b853338d40a2c40a4a41f59bd053744b44b96a8d11b6df054363c99d9b6c0e5e28b811547f5af48471a522185477b3f2145e3a6b9cca432f75473dfecda3247e5b749d11ed25f269f8d534ff03cbac13141a0937f9f3508618553d2e093cb8d04206454bc085a4fa7fe836b1a9dde85a488319351bd826c4ae7981288e3189a265bc86475029f1bf9912a729ff977a27543e859e95c4cab4b213eea2ca5d08b211d1c1d267932ed528f321a169797312740f9f98a52afb1d1d94d526cf9d0f83a62044fa2ed9c819dd3e1359e6671c8605246a8fc578e3ce8001fb21712a961a6e350d560724f0cc58b628424ddc13608bff76b20089abef256270a7a247f1aa9a14a91cce728f2bf617d70913b590ab86e5d422e5283ef16ce5d3cf0cec17828a6cb1082082e898545d08d18f99b61a1ad8ca2bf47a37d4a2c72decbf24126641a0a25930de9756067603ee6d67bb63478d645cb3e378119075af2e672553bc0142fb4ec5e465e2da6621d51e196957ebcd119d4a635c0cadcf5083c3598ce4966d9706b283be26d04e660da9807deece57e80ad3d69e023cd5716701368b83625f95d716b1916cf64a45964d8ab5492c2662d64e240e1ebe73fcb2edad995e4f80f4dde577090e9d400a93a8a9af801957f07043ef91a9fd41405b43bc3e01a23e2f70fbc6229969da56f3ad5cb7e6040b767187ca62768c6e338e01a78f8a295b3ed5bf1bbed68454d7f747f5f0720cf2c560852cd6ab5d840dd8fa6d00095de27cbc5166cecc9740c436fdfc641378767180e87c5df721829b32ccad7cb58a73413a069bf44c6a0e0efb7f7b03f86c42e7954695f0ecf106c12f9dfe0cc25eea1734fb48c633d18fbd9d118206aebdb3f8a08f77ee6f7425bae3bd49942cf6cc2b0ed47a7f65a5256fc76ed2f2436c4eee2d335b4f3706ec7359a25512672dc4f07e7d7a24d91bdb6e82e011e6c1ca238a7ceb35af12a39cf1a924c1653d33a8106869db94523f450532e42fc034608d6162d127751dc3c14bba5dd20354df45d942c91a358ebf1c382207e2bf7094908f19aea665bede6323762e35bffa4f4fe282850ea490f36ef6d5f01d657b35b086f2016f27530efb80d37948a6d7c68dd0f2167e25f234837937140c08b9a19a3d7da9539227564fc1fda4b07afb0f40d0d66306eae721a7a2d413c70f9947406a7a47111612092a736b61a13b632a12d78c7a0b7056531e172802e8970d652de13085015a7601c58e4e370c171e819f74dd5f4b91310c53666cc6e311119e7bc6d6");
#endif

    CBlock block = CreateGenesisBlock(PastelGenesisTimestamp, PastelGenesisPubKey, EpocTime, nNonce, nSolution, nBits);

#ifdef MINE_GENESIS_TEST
    MineGenesis::__mineGenBlock("TestNet", true, 200, 9, &block);
#endif
    return block;
}
static const uint256 TestnetHashGenesisBlock = uint256S("07868deac6fb30e83f15d077a4ef3a5957d36f84793643ba9c8df475aa397e20");

static CBlock CreateRegtestGenesisBlock()
{
    uint32_t nTime = EpocTime;
    uint32_t nBits = 0x200f0f0f;

#ifdef MINE_GENESIS_REGT
    uint256 nNonce = uint256S("0");
    std::vector<unsigned char> nSolution = ParseHex("0");
#else
    uint256 nNonce = uint256S("0000000000000000000000000000000000000000000000000000000000000009");
    std::vector<unsigned char> nSolution = ParseHex("06feb49c057759b8dd1a9810ea32c191fda910e7f27b68f7c387e737ecdeb6e39b554d5f");
#endif

    CBlock block = CreateGenesisBlock(PastelGenesisTimestamp, PastelGenesisPubKey, EpocTime, nNonce, nSolution, nBits);

#ifdef MINE_GENESIS_REGT
    MineGenesis::__mineGenBlock("RegTest", false, 48, 5, &block);
#endif

    return block;
}
static const uint256 RegtestHashGenesisBlock = uint256S("0e584b4ae690899a4597b995b9434b81e2695606a74f4a5b83e1184f855253b9");

/**
 * Main network
 */
/**
 * What makes a good checkpoint block?
 * + Is surrounded by blocks with reasonable timestamps
 *   (no blocks before with a timestamp after, none after with
 *    timestamp before)
 * + Contains no strange transactions
 */

const arith_uint256 maxUint = UintToArith256(uint256S("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));

class CMainParams : public CChainParams {
public:
    CMainParams() {
        strNetworkID = "main";
        network = CBaseChainParams::MAIN;
        strCurrencyUnits = "PSL";
        bip44CoinType = 133; // As registered in https://github.com/patoshilabs/slips/blob/master/slip-0044.md
        consensus.nSubsidyHalvingInterval = 840000;
        consensus.nMajorityEnforceBlockUpgrade = 750;
        consensus.nMajorityRejectBlockOutdated = 950;
        consensus.nMajorityWindow = 4000;
        consensus.powLimit = uint256S("0007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
        consensus.nPowAveragingWindow = 17;
        assert(maxUint/UintToArith256(consensus.powLimit) >= consensus.nPowAveragingWindow);
        consensus.nPowMaxAdjustDown = 32; // 32% adjustment down
        consensus.nPowMaxAdjustUp = 16; // 16% adjustment up
        consensus.nPowTargetSpacing = 2.5 * 60;
        consensus.nPowAllowMinDifficultyBlocksAfterHeight = boost::none;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nActivationHeight = Consensus::NetworkUpgrade::ALWAYS_ACTIVE;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nActivationHeight = Consensus::NetworkUpgrade::NO_ACTIVATION_HEIGHT;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nProtocolVersion = 170005;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nActivationHeight = OVERWINTER_STARTING_BLOCK;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nProtocolVersion = 170007;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nActivationHeight = SAPLING_STARTING_BLOCK;
        consensus.nMaxGovernanceAmount = 1000000*COIN;

        // The best chain should have at least this much work.
        consensus.nMinimumChainWork = uint256S("0x000000000000000000000000000000000000000000000000006f31c0e1f30221");
        
        /**
         * The message start string
         */
        pchMessageStart[0] = 0x6b;
        pchMessageStart[1] = 0xda;
        pchMessageStart[2] = 0xb8;
        pchMessageStart[3] = 0xfc;
        vAlertPubKey = ParseHex("0441f3821b035bc418b8fbe8e912005112826a5c51fdcf5fbac6d7dd2ab545183049e51c3f2ed2a70b1e48a59b4c3367c15d30fbff461afc6b83932fefedfe5d41");
        nDefaultPort = 9933;
        nPruneAfterHeight = 100000;
        const size_t N = 200, K = 9;
        BOOST_STATIC_ASSERT(equihash_parameters_acceptable(N, K));
        nEquihashN = N;
        nEquihashK = K;

        genesis = CreateMainnetGenesisBlock();
        consensus.hashGenesisBlock = genesis.GetHash();
#ifndef MINE_GENESIS
        assert(consensus.hashGenesisBlock == MainnetHashGenesisBlock);
        assert(genesis.hashMerkleRoot == MainnetHashMerkleRoot);
#endif

        vFixedSeeds.clear();
        vSeeds.clear();
        vSeeds.push_back(CDNSSeedData("pastel.network", "mainnet.pastel.network"));

        // guarantees the first 2 characters, when base58 encoded, are "Pt"
        base58Prefixes[PUBKEY_ADDRESS]     = {0x0c,0xe3};
        // guarantees the first 2 characters, when base58 encoded, are "pt"
        base58Prefixes[SCRIPT_ADDRESS]     = {0x1a,0xF6};
        // the first character, when base58 encoded, is "5" or "K" or "L" (as in Bitcoin)
        base58Prefixes[SECRET_KEY]         = {0x80};
        // do not rely on these BIP32 prefixes; they are not specified and may change
        base58Prefixes[EXT_PUBLIC_KEY]     = {0x04,0x88,0xB2,0x1E};
        base58Prefixes[EXT_SECRET_KEY]     = {0x04,0x88,0xAD,0xE4};
        // guarantees the first 2 characters, when base58 encoded, are "Pz"
        base58Prefixes[ZCPAYMENT_ADDRRESS] = {0x09,0x05};
        // guarantees the first 4 characters, when base58 encoded, are "Px"
        base58Prefixes[ZCVIEWING_KEY]      = {0x09,0x01};
        // guarantees the first 2 characters, when base58 encoded, are "Ps"
        base58Prefixes[ZCSPENDING_KEY]     = {0x9A,0x90};

        bech32HRPs[SAPLING_PAYMENT_ADDRESS]      = "ps";
        bech32HRPs[SAPLING_FULL_VIEWING_KEY]     = "pviews";
        bech32HRPs[SAPLING_INCOMING_VIEWING_KEY] = "pivks";
        bech32HRPs[SAPLING_EXTENDED_SPEND_KEY]   = "p-secret-extended-key-main";

        vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_main, pnSeed6_main + ARRAYLEN(pnSeed6_main));

        fMiningRequiresPeers = true;
        fDefaultConsistencyChecks = false;
        fRequireStandard = true;
        fMineBlocksOnDemand = false;
        fTestnetToBeDeprecatedFieldRPC = false;

        checkpointData = (CCheckpointData) {
            boost::assign::map_list_of
            (0, consensus.hashGenesisBlock)
            (1184, uint256S("0x000345793ed6cfb2d5a2271193a5169f1cfd00c131cbf98997b6d37940d0cc78")),
            1584396040/*genesis.nTime*/,      // * UNIX timestamp of last checkpoint block
            1205,                  // * total number of transactions between genesis and last checkpoint
                                //   (the tx=... number in the UpdateTip debug.log lines - "UpdateTip: new best=... tx=...")
            600                 // * estimated number of transactions per day after checkpoint
                                //   total number of tx / (checkpoint block height / (24 * 24))
                                //after first checkpoint math is = 586, but I'm setting 600
        };
    }
};
static CMainParams mainParams;

/**
 * Testnet (v3)
 */
class CTestNetParams : public CChainParams {
public:
    CTestNetParams() {
        strNetworkID = "test";
        network = CBaseChainParams::TESTNET;
        strCurrencyUnits = "LSP";
        bip44CoinType = 1;
        consensus.nSubsidyHalvingInterval = 840000;
        consensus.nMajorityEnforceBlockUpgrade = 51;
        consensus.nMajorityRejectBlockOutdated = 75;
        consensus.nMajorityWindow = 400;
        consensus.powLimit = uint256S("07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
        consensus.nPowAveragingWindow = 17;
        assert(maxUint/UintToArith256(consensus.powLimit) >= consensus.nPowAveragingWindow);
        consensus.nPowMaxAdjustDown = 32; // 32% adjustment down
        consensus.nPowMaxAdjustUp = 16; // 16% adjustment up
        consensus.nPowTargetSpacing = 2.5 * 60;
        consensus.nPowAllowMinDifficultyBlocksAfterHeight = 299187;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nActivationHeight = Consensus::NetworkUpgrade::ALWAYS_ACTIVE;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nActivationHeight = Consensus::NetworkUpgrade::NO_ACTIVATION_HEIGHT;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nProtocolVersion = 170003;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nActivationHeight = OVERWINTER_STARTING_BLOCK;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nProtocolVersion = 170007;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nActivationHeight = SAPLING_STARTING_BLOCK;
        consensus.nMaxGovernanceAmount = 1000000*COIN;

        // The best chain should have at least this much work.
        consensus.nMinimumChainWork = uint256S("0x00000000000000000000000000000000000000000000000000000001d0c4d9cd");

        /**
         * The message start string
         */
        pchMessageStart[0] = 0x38;
        pchMessageStart[1] = 0xb6;
        pchMessageStart[2] = 0xfe;
        pchMessageStart[3] = 0x64;
        vAlertPubKey = ParseHex("0429aff40718031ed61f0166f3e33b5dfb256c78cdbfa916bf6cc9869a40ce1d66ca35b92fe874bd18b69457ecef27bc3a0f089b737b03fb889dc1420b6a6e70cb");
        nDefaultPort = 19933;
        nPruneAfterHeight = 1000;
        const size_t N = 200, K = 9;
        BOOST_STATIC_ASSERT(equihash_parameters_acceptable(N, K));
        nEquihashN = N;
        nEquihashK = K;

        genesis = CreateTestnetGenesisBlock();
        consensus.hashGenesisBlock = genesis.GetHash();
#ifndef MINE_GENESIS
        assert(consensus.hashGenesisBlock == TestnetHashGenesisBlock);
#endif

        vFixedSeeds.clear();
        vSeeds.clear();
        vSeeds.push_back(CDNSSeedData("pastel.network", "dnsseed.testnet.pastel.network"));

        // guarantees the first 2 characters, when base58 encoded, are "tP"
        base58Prefixes[PUBKEY_ADDRESS]     = {0x1C,0xEF};
        // guarantees the first 2 characters, when base58 encoded, are "tt"
        base58Prefixes[SCRIPT_ADDRESS]     = {0x1D,0x37};
        // the first character, when base58 encoded, is "9" or "c" (as in Bitcoin)
        base58Prefixes[SECRET_KEY]         = {0xEF};
        // do not rely on these BIP32 prefixes; they are not specified and may change
        base58Prefixes[EXT_PUBLIC_KEY]     = {0x04,0x35,0x87,0xCF};
        base58Prefixes[EXT_SECRET_KEY]     = {0x04,0x35,0x83,0x94};
        // guarantees the first 2 characters, when base58 encoded, are "tZ"
        base58Prefixes[ZCPAYMENT_ADDRRESS] = {0x14,0x3A};
        // guarantees the first 4 characters, when base58 encoded, are "tX"
        base58Prefixes[ZCVIEWING_KEY]      = {0x14,0x37};
        // guarantees the first 2 characters, when base58 encoded, are "tQ" OR "tS"
        base58Prefixes[ZCSPENDING_KEY]     = {0x05,0xFE};

        bech32HRPs[SAPLING_PAYMENT_ADDRESS]      = "ptestsapling";
        bech32HRPs[SAPLING_FULL_VIEWING_KEY]     = "pviewtestsapling";
        bech32HRPs[SAPLING_INCOMING_VIEWING_KEY] = "pivktestsapling";
        bech32HRPs[SAPLING_EXTENDED_SPEND_KEY]   = "p-secret-extended-key-test";

        vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_test, pnSeed6_test + ARRAYLEN(pnSeed6_test));

        fMiningRequiresPeers = true;
        fDefaultConsistencyChecks = false;
        fRequireStandard = true;
        fMineBlocksOnDemand = false;
        fTestnetToBeDeprecatedFieldRPC = true;


        checkpointData = (CCheckpointData) {
            boost::assign::map_list_of
            (0, consensus.hashGenesisBlock),
            genesis.nTime,      // * UNIX timestamp of last checkpoint block
            0,                  // * total number of transactions between genesis and last checkpoint
                                //   (the tx=... number in the SetBestChain debug.log lines)
            250                 // * estimated number of transactions per day after checkpoint
                                //   total number of tx / (checkpoint block height / (24 * 24))
        };
    }
};
static CTestNetParams testNetParams;

/**
 * Regression test
 */
class CRegTestParams : public CChainParams {
public:
    CRegTestParams() {
        strNetworkID = "regtest";
        network = CBaseChainParams::REGTEST;
        strCurrencyUnits = "REG";
        bip44CoinType = 1;
        consensus.nSubsidyHalvingInterval = 150;
        consensus.nMajorityEnforceBlockUpgrade = 750;
        consensus.nMajorityRejectBlockOutdated = 950;
        consensus.nMajorityWindow = 1000;
        consensus.powLimit = uint256S("0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f");
        consensus.nPowAveragingWindow = 17;
        assert(maxUint/UintToArith256(consensus.powLimit) >= consensus.nPowAveragingWindow);
        consensus.nPowMaxAdjustDown = 0; // Turn off adjustment down
        consensus.nPowMaxAdjustUp = 0; // Turn off adjustment up
        consensus.nPowTargetSpacing = 2.5 * 60;
        consensus.nPowAllowMinDifficultyBlocksAfterHeight = 0;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nActivationHeight = Consensus::NetworkUpgrade::ALWAYS_ACTIVE;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nActivationHeight = Consensus::NetworkUpgrade::NO_ACTIVATION_HEIGHT;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nProtocolVersion = 170003;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nActivationHeight = Consensus::NetworkUpgrade::NO_ACTIVATION_HEIGHT;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nProtocolVersion = 170006;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nActivationHeight = Consensus::NetworkUpgrade::NO_ACTIVATION_HEIGHT;
        consensus.nMaxGovernanceAmount = 1000000*COIN;

        // The best chain should have at least this much work.
        consensus.nMinimumChainWork = uint256S("0x00");

        /**
         * The message start string
         */
        pchMessageStart[0] = 0xcd;
        pchMessageStart[1] = 0xd8;
        pchMessageStart[2] = 0xfa;
        pchMessageStart[3] = 0x9e;
        vAlertPubKey = ParseHex("04b985ccafe6d17ac5d84cb8c06a69cefad733ee96b4b93bcf5ef0897778c227ee7e74e7680cc219236e4c6a609dbcdeb5bf65cea9c2576c2a0fbef590657c8e7a");
        nDefaultPort = 18344;
        nPruneAfterHeight = 1000;
        const size_t N = 48, K = 5;
        BOOST_STATIC_ASSERT(equihash_parameters_acceptable(N, K));
        nEquihashN = N;
        nEquihashK = K;
        
        genesis = CreateRegtestGenesisBlock();
        consensus.hashGenesisBlock = genesis.GetHash();
#ifndef MINE_GENESIS
        assert(consensus.hashGenesisBlock == RegtestHashGenesisBlock);
#endif

        vFixedSeeds.clear(); //! Regtest mode doesn't have any fixed seeds.
        vSeeds.clear();  //! Regtest mode doesn't have any DNS seeds.

        // These prefixes are the same as the testnet prefixes
        // guarantees the first 2 characters, when base58 encoded, are "tP"
        base58Prefixes[PUBKEY_ADDRESS]     = {0x1C,0xEF};
        // guarantees the first 2 characters, when base58 encoded, are "tt"
        base58Prefixes[SCRIPT_ADDRESS]     = {0x1D,0x37};
        // the first character, when base58 encoded, is "9" or "c" (as in Bitcoin)
        base58Prefixes[SECRET_KEY]         = {0xEF};
        // do not rely on these BIP32 prefixes; they are not specified and may change
        base58Prefixes[EXT_PUBLIC_KEY]     = {0x04,0x35,0x87,0xCF};
        base58Prefixes[EXT_SECRET_KEY]     = {0x04,0x35,0x83,0x94};
        // guarantees the first 2 characters, when base58 encoded, are "tZ"
        base58Prefixes[ZCPAYMENT_ADDRRESS] = {0x14,0x3A};
        // guarantees the first 4 characters, when base58 encoded, are "tX"
        base58Prefixes[ZCVIEWING_KEY]      = {0x14,0x37};
        // guarantees the first 2 characters, when base58 encoded, are "tQ" OR "tS"
        base58Prefixes[ZCSPENDING_KEY]     = {0x05,0xFE};

        bech32HRPs[SAPLING_PAYMENT_ADDRESS]      = "pzregtestsapling";
        bech32HRPs[SAPLING_FULL_VIEWING_KEY]     = "pviewregtestsapling";
        bech32HRPs[SAPLING_INCOMING_VIEWING_KEY] = "pivkregtestsapling";
        bech32HRPs[SAPLING_EXTENDED_SPEND_KEY]   = "p-secret-extended-key-regtest";

        fMiningRequiresPeers = false;
        fDefaultConsistencyChecks = true;
        fRequireStandard = false;
        fMineBlocksOnDemand = true;
        fTestnetToBeDeprecatedFieldRPC = false;

        checkpointData = (CCheckpointData){
            boost::assign::map_list_of
            (0, consensus.hashGenesisBlock),
            genesis.nTime,
            0,
            0
        };
    }

    void UpdateNetworkUpgradeParameters(Consensus::UpgradeIndex idx, int nActivationHeight)
    {
        assert(idx > Consensus::BASE_SPROUT && idx < Consensus::MAX_NETWORK_UPGRADES);
        consensus.vUpgrades[idx].nActivationHeight = nActivationHeight;
    }
};
static CRegTestParams regTestParams;

static CChainParams *pCurrentParams = 0;

const CChainParams &Params() {
    assert(pCurrentParams);
    return *pCurrentParams;
}

CChainParams &Params(CBaseChainParams::Network network) {
    switch (network) {
        case CBaseChainParams::MAIN:
            return mainParams;
        case CBaseChainParams::TESTNET:
            return testNetParams;
        case CBaseChainParams::REGTEST:
            return regTestParams;
        default:
            assert(false && "Unimplemented network");
            return mainParams;
    }
}

void SelectParams(CBaseChainParams::Network network) {
    SelectBaseParams(network);
    pCurrentParams = &Params(network);
}

bool SelectParamsFromCommandLine()
{
    CBaseChainParams::Network network = NetworkIdFromCommandLine();
    if (network == CBaseChainParams::MAX_NETWORK_TYPES)
        return false;

    SelectParams(network);
    return true;
}

void UpdateNetworkUpgradeParameters(Consensus::UpgradeIndex idx, int nActivationHeight)
{
    regTestParams.UpdateNetworkUpgradeParameters(idx, nActivationHeight);
}
